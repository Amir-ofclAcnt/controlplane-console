generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

/// * Auth.js / NextAuth models (Prisma Adapter)
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]

  memberships OrgMember[]

  auditLogs AuditLog[] @relation("AuditActor")

  // Optional: if you want to attribute who created an API key / snapshot
  createdApiKeys   ApiKey[]         @relation("ApiKeyCreator")
  createdSnapshots ConfigSnapshot[] @relation("SnapshotCreator")
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

/// * Product domain models
model Organization {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  auditLogs AuditLog[]
  members   OrgMember[]
  projects  Project[]
}

model OrgMember {
  id             String  @id @default(cuid())
  organizationId String
  userId         String
  role           OrgRole @default(OWNER)

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@index([userId])
}

model Project {
  id             String   @id @default(cuid())
  organizationId String
  name           String
  slug           String
  createdAt      DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  environments Environment[]
  apiKeys      ApiKey[]
  requestLogs  RequestLog[]
  events       Event[]

  flags    FeatureFlag[]
  segments Segment[]

  @@unique([organizationId, slug])
  @@index([organizationId])
}

model Environment {
  id        String @id @default(cuid())
  projectId String

  // Display name can change; slug should be stable (dev/staging/prod)
  name String
  slug String? // Migration 1: optional; later make required and unique per project

  createdAt DateTime @default(now())

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  // LaunchDarkly-like config per environment
  flagStates FlagEnvironmentState[]
  snapshots  ConfigSnapshot[]

  // Scoping for keys + logs + events
  apiKeys     ApiKey[]
  requestLogs RequestLog[]
  events      Event[]

  // Keep your existing uniqueness for now (safe); later you can switch to unique([projectId, slug])
  @@unique([projectId, name])
  @@index([projectId])
}

model ApiKey {
  id        String @id @default(cuid())
  projectId String

  // Migration 1: optional; backfill then make required
  environmentId String?

  name   String
  prefix String
  hash   String @unique

  revokedAt  DateTime?
  lastUsedAt DateTime?

  createdByUserId String?

  createdAt DateTime @default(now())

  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  environment Environment? @relation(fields: [environmentId], references: [id], onDelete: SetNull)

  createdBy User? @relation("ApiKeyCreator", fields: [createdByUserId], references: [id], onDelete: SetNull)

  requestLogs RequestLog[]
  events      Event[]

  @@unique([projectId, prefix])
  @@index([projectId])
  @@index([environmentId])
  @@index([revokedAt])
}

model RequestLog {
  id        String @id @default(cuid())
  projectId String

  // Migration 1: optional; later make required if you want strict env filtering
  environmentId String?

  apiKeyId  String?
  method    String
  path      String
  status    Int
  latencyMs Int
  ip        String?
  userAgent String?
  createdAt DateTime @default(now())

  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  environment Environment? @relation(fields: [environmentId], references: [id], onDelete: SetNull)
  apiKey      ApiKey?      @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)

  @@index([projectId, createdAt])
  @@index([environmentId, createdAt])
  @@index([apiKeyId, createdAt])
}

/// Optional but recommended for LaunchDarkly-style ingestion parity
model Event {
  id            String  @id @default(cuid())
  projectId     String
  environmentId String?
  apiKeyId      String?

  // Your event schema can evolve; store raw JSON plus a few searchable fields
  type        String?
  payloadJson Json

  receivedAt DateTime @default(now())

  project     Project      @relation(fields: [projectId], references: [id], onDelete: Cascade)
  environment Environment? @relation(fields: [environmentId], references: [id], onDelete: SetNull)
  apiKey      ApiKey?      @relation(fields: [apiKeyId], references: [id], onDelete: SetNull)

  @@index([projectId, receivedAt])
  @@index([environmentId, receivedAt])
  @@index([apiKeyId, receivedAt])
}

model AuditLog {
  id             String   @id @default(cuid())
  organizationId String
  actorUserId    String?
  action         String
  targetType     String
  targetId       String
  metaJson       Json?
  createdAt      DateTime @default(now())

  actor        User?        @relation("AuditActor", fields: [actorUserId], references: [id], onDelete: SetNull)
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@index([organizationId, createdAt])
  @@index([actorUserId, createdAt])
}

enum OrgRole {
  OWNER
  ADMIN
  DEVELOPER
  VIEWER
}

/// ===============================
/// LaunchDarkly-like Feature Flags
/// ===============================
enum FlagKind {
  BOOLEAN
  STRING
  NUMBER
  JSON
}

model FeatureFlag {
  id        String @id @default(cuid())
  projectId String

  // Stable identifier used by SDKs (e.g. "checkout_redesign")
  key         String
  name        String
  description String?
  kind        FlagKind @default(BOOLEAN)

  archivedAt DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  variations FlagVariation[]
  envStates  FlagEnvironmentState[]

  @@unique([projectId, key])
  @@index([projectId])
}

model FlagVariation {
  id        String   @id @default(cuid())
  flagId    String
  name      String?
  value     Json
  order     Int
  createdAt DateTime @default(now())

  flag FeatureFlag @relation(fields: [flagId], references: [id], onDelete: Cascade)

  @@unique([flagId, order])
  @@index([flagId])
}

model FlagEnvironmentState {
  id            String @id @default(cuid())
  flagId        String
  environmentId String

  enabled Boolean @default(false)

  // Serve this variation when flag is OFF
  offVariationId String?

  // Serve this when no rules match (or rollout fallthrough)
  fallthroughId String?

  // Store targeting/rules as JSON initially (fast iteration; enterprise-ready with snapshots)
  // Example shapes are up to you.
  targetsJson Json?
  rulesJson   Json?

  // Optional: track events for this flag in this env
  trackEvents Boolean @default(false)

  updatedAt DateTime @updatedAt

  flag        FeatureFlag @relation(fields: [flagId], references: [id], onDelete: Cascade)
  environment Environment @relation(fields: [environmentId], references: [id], onDelete: Cascade)

  @@unique([flagId, environmentId])
  @@index([environmentId])
  @@index([flagId])
}

/// ===============================
/// Segments (reusable targeting)
/// ===============================
model Segment {
  id          String  @id @default(cuid())
  projectId   String
  key         String
  name        String
  description String?

  includedJson Json?
  excludedJson Json?
  rulesJson    Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  project Project @relation(fields: [projectId], references: [id], onDelete: Cascade)

  @@unique([projectId, key])
  @@index([projectId])
}

/// ===============================
/// Published config snapshots
/// ===============================
enum SnapshotStatus {
  DRAFT
  PUBLISHED
  ROLLED_BACK
}

model ConfigSnapshot {
  id            String         @id @default(cuid())
  environmentId String
  version       Int
  status        SnapshotStatus @default(DRAFT)

  // Immutable blob read by data plane / SDK delivery
  contentJson   Json
  contentSha256 String

  createdByUserId String?
  createdAt       DateTime  @default(now())
  publishedAt     DateTime?

  environment Environment @relation(fields: [environmentId], references: [id], onDelete: Cascade)
  createdBy   User?       @relation("SnapshotCreator", fields: [createdByUserId], references: [id], onDelete: SetNull)

  @@unique([environmentId, version])
  @@unique([environmentId, contentSha256])
  @@index([environmentId, status])
}


